use super::masks::Mask;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
#[repr(u64)]
pub enum Color {
    White = Mask::board([0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]).as_u64(),
    Black = Mask::board([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF]).as_u64(),
}

impl Color {
    pub const fn as_mask(&self) -> Mask {
        Mask::new(*self as u64)
    }
}

#[rustfmt::skip]
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
#[repr(u64)]
pub enum Shade {
    Light = Mask::board([0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55]).as_u64(),
    Dark =  Mask::board([0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA]).as_u64(),
}

impl Shade {
    pub const fn as_mask(&self) -> Mask {
        Mask::new(*self as u64)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
#[repr(u64)]
pub enum Rank {
    _8 = Mask::board([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF]).as_u64(),
    _7 = Mask::board([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00]).as_u64(),
    _6 = Mask::board([0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00]).as_u64(),
    _5 = Mask::board([0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00]).as_u64(),
    _4 = Mask::board([0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00]).as_u64(),
    _3 = Mask::board([0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00]).as_u64(),
    _2 = Mask::board([0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]).as_u64(),
    _1 = Mask::board([0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]).as_u64(),
}

impl Rank {
    pub const fn as_mask(&self) -> Mask {
        Mask::new(*self as u64)
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
#[repr(u64)]
pub enum File {
    A = Mask::board([0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]).as_u64(),
    B = Mask::board([0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40]).as_u64(),
    C = Mask::board([0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20]).as_u64(),
    D = Mask::board([0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10]).as_u64(),
    E = Mask::board([0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08]).as_u64(),
    F = Mask::board([0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04]).as_u64(),
    G = Mask::board([0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02]).as_u64(),
    H = Mask::board([0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]).as_u64(),
}

impl File {
    pub const fn as_mask(&self) -> Mask {
        Mask::new(*self as u64)
    }
}

#[rustfmt::skip]
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
#[repr(u64)]
pub enum Piece {
    Pawn =   Mask::board([0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00]).as_u64(),
    Knight = Mask::board([0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42]).as_u64(),
    Bishop = Mask::board([0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24]).as_u64(),
    Rook =   Mask::board([0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81]).as_u64(),
    Queen =  Mask::board([0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10]).as_u64(),
    King =   Mask::board([0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08]).as_u64(),
}

impl Piece {
    pub const fn as_mask(&self) -> Mask {
        Mask::new(*self as u64)
    }
}
